import { isIPv6 } from 'node:net'

/**
 * Returns the IP address itself for IPv4, or a CIDR-notation subnet for IPv6.
 *
 * If you write a custom keyGenerator that allows a fallback to IP address for
 * unauthenticated users, return ipKeyGenerator(req.ip) rather than just req.ip.
 *
 * For more information, {@see Options.ipv6Subnet}.
 *
 * @param ip {string} - The IP address to process, usually request.ip.
 * @param ipv6Subnet {number | false} - The subnet mask for IPv6 addresses.
 *
 * @returns {string} - The key generated from the IP address
 *
 * @public
 */
export function ipKeyGenerator(ip: string, ipv6Subnet: number | false = 56) {
	if (ipv6Subnet && isIPv6(ip)) {
		// For IPv6, return the network address of the subnet in CIDR format
		try {
			return getIpv6NetworkAddress(ip, ipv6Subnet)
		} catch (error) {
			// log an error, but don't crash the app
			console.error(
				`Error applying subnet ${ipv6Subnet} to IPv6 address ${ip}: ${error}`,
			)
			return ip
		}
	}

	// For IPv4, just return the IP address itself
	return ip
}

// Below code generated by Google Gemini 2.5 Pro (formatted by biome)
// I originally tried several libraries, but they either had issues with our typescript compilation or known vulnerabilities.
// I think it gets all of the fiddly bits correct, and it passes both my tests and the ones gemini wrote for it.

/**
 * Helper to expand a compressed IPv6 address into its full 8-group,
 * 16-bit-per-group representation. It also handles IPv4-mapped addresses.
 * Example: "::ffff:127.0.0.1" -> ["0000", "0000", "0000", "0000", "0000", "ffff", "7f00", "0001"]
 * @param addr The IPv6 address string.
 * @returns An array of 8 strings, each representing a 16-bit group in hex.
 * @throws {Error} if the address format is invalid.
 */
function expandIpv6(addr: string): string[] {
	let ipv4HexGroups: string[] = []
	let ipv6Part = addr

	// Check for and process an embedded IPv4 address first.
	if (addr.includes('.')) {
		const lastColonIndex = addr.lastIndexOf(':')
		if (lastColonIndex === -1) {
			throw new Error('Invalid IPv4-mapped IPv6 address: no colon found.')
		}

		ipv6Part = addr.substring(0, lastColonIndex)
		const ipv4Part = addr.substring(lastColonIndex + 1)

		const ipv4Octets = ipv4Part.split('.').map(Number)
		if (
			ipv4Octets.length !== 4 ||
			ipv4Octets.some((o) => Number.isNaN(o) || o < 0 || o > 255)
		) {
			throw new Error('Invalid IPv4 part in IPv6 address.')
		}

		// Convert IPv4 octets to two 16-bit hex groups.
		const hexGroup1 = ((ipv4Octets[0] << 8) | ipv4Octets[1]).toString(16)
		const hexGroup2 = ((ipv4Octets[2] << 8) | ipv4Octets[3]).toString(16)
		ipv4HexGroups = [hexGroup1, hexGroup2]
	}

	// Now, expand the IPv6 part.
	const parts = ipv6Part.split('::')
	if (parts.length > 2) {
		throw new Error('Invalid IPv6 address: contains more than one "::".')
	}

	let left = parts[0] ? parts[0].split(':') : []
	let right = parts.length > 1 && parts[1] ? parts[1].split(':') : []

	if (left.length === 1 && left[0] === '') left = []
	if (right.length === 1 && right[0] === '') right = []

	// The number of groups to fill with zeros depends on whether we have an IPv4 part.
	const totalGroups = 8
	const existingGroups = left.length + right.length + ipv4HexGroups.length
	const zeroGroupsCount = totalGroups - existingGroups

	if (zeroGroupsCount < 0) {
		throw new Error('Invalid IPv6 address: too many groups.')
	}

	const zeros = Array(zeroGroupsCount).fill('0000')

	// Combine all parts and pad them with leading zeros to 4 hex digits.
	const fullAddressGroups = [...left, ...zeros, ...right, ...ipv4HexGroups]
	return fullAddressGroups.map((group) => group.padStart(4, '0'))
}

/**
 * Helper to convert an IPv6 address string into a BigInt.
 * @param addr The IPv6 address string.
 * @returns A BigInt representation of the IPv6 address.
 */
function ipv6ToBigInt(addr: string): bigint {
	const expandedGroups = expandIpv6(addr)
	if (expandedGroups.length !== 8) {
		throw new Error('Invalid IPv6 address format after expansion.')
	}
	const hexString = expandedGroups.join('')
	return BigInt(`0x${hexString}`)
}

/**
 * Helper to convert a BigInt back to a compressed IPv6 string.
 * @param ip The BigInt representation of an IPv6 address.
 * @returns A compressed IPv6 address string.
 */
function bigIntToIpv6(ip: bigint): string {
	// Convert the BigInt to a 32-character hexadecimal string, padded with zeros
	const hexString = ip.toString(16).padStart(32, '0')

	// Split the hex string into 8 groups of 4 characters
	const groups = hexString.match(/.{1,4}/g) || []

	// Find the longest consecutive sequence of zero groups for compression
	let longestZeroSequence = { start: -1, length: 0 }
	let currentZeroSequence = { start: -1, length: 0 }

	groups.forEach((group, i) => {
		if (group === '0000') {
			if (currentZeroSequence.start === -1) {
				currentZeroSequence.start = i
			}
			currentZeroSequence.length++
		} else {
			if (currentZeroSequence.length > longestZeroSequence.length) {
				longestZeroSequence = { ...currentZeroSequence }
			}
			currentZeroSequence = { start: -1, length: 0 }
		}
	})
	// Check one last time after the loop
	if (currentZeroSequence.length > longestZeroSequence.length) {
		longestZeroSequence = { ...currentZeroSequence }
	}

	// If we found a compressible sequence (more than one zero group)
	if (longestZeroSequence.length > 1) {
		const { start, length } = longestZeroSequence

		// Helper to process a slice of groups into a string, removing leading zeros.
		const processSlice = (slice: string[]) =>
			slice.map((g) => g.replace(/^0+/, '') || '0').join(':')

		const leftStr = processSlice(groups.slice(0, start))
		const rightStr = processSlice(groups.slice(start + length))

		// Combine the parts with "::". This elegantly handles all cases
		// (e.g., ::1, 1::, 1::1, ::) by joining the left and right parts.
		// An empty part on either side results in correct compression.
		return [leftStr, rightStr].join('::')
	}

	// No compression, just remove leading zeros from each group
	return groups.map((group) => group.replace(/^0+/, '') || '0').join(':')
}

/**
 * Applies a subnet mask to an IPv6 address and returns the resulting network
 * address in CIDR notation.
 *
 * @param ipv6Address The IPv6 address string. It can be in any valid format,
 * including compressed (e.g., "::1") or full.
 * @param subnetMask A number between 0 and 128 representing the subnet mask.
 * @returns The calculated network address as a string in compressed CIDR
 * notation (e.g., "2001:db8::/32").
 * @throws {Error} if the IPv6 address is invalid or the subnet mask is out of range.
 */
export function getIpv6NetworkAddress(
	ipv6Address: string,
	subnetMask: number,
): string {
	// --- 1. Validate Inputs ---
	if (subnetMask < 0 || subnetMask > 128) {
		throw new Error(
			'Invalid subnet mask. Must be an integer between 0 and 128.',
		)
	}

	// --- 2. Convert IP to BigInt and Apply Mask ---
	const ipAsBigInt = ipv6ToBigInt(ipv6Address)

	// Create the bitmask as a BigInt.
	// The mask is a sequence of `subnetMask` ones, followed by `128 - subnetMask` zeros.
	// We achieve this by taking the maximum 128-bit integer ((2^128) - 1) and
	// left-shifting it to zero out the host bits.
	// Note: Shifting by 128 is undefined in JS for BigInt, so handle mask 0 as a special case.
	const maskBigInt =
		subnetMask === 0 ? 0n : ((1n << 128n) - 1n) << BigInt(128 - subnetMask)

	// Apply the mask using bitwise AND
	const networkBigInt = ipAsBigInt & maskBigInt

	// --- 3. Format Output ---
	const networkAddressString = bigIntToIpv6(networkBigInt)

	return `${networkAddressString}/${subnetMask}`
}
